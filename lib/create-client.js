// Generated by CoffeeScript 1.8.0
(function() {
  var EventEmitter, Network, Peer, TCP, UDP, UDPHoleClient,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  UDP = require("dgram");

  TCP = require("net");

  Network = require("network");

  EventEmitter = require("events").EventEmitter;

  Peer = (function(_super) {
    __extends(Peer, _super);

    function Peer(host, socket) {
      this.host = host;
      this.socket = socket;
      this.send = __bind(this.send, this);
      this.receive = __bind(this.receive, this);
      this.connectionHandler = __bind(this.connectionHandler, this);
      this.ack = {
        requests: 0,
        acked: false
      };
      this.ackInterval = null;
    }

    Peer.prototype.initialize = function() {
      return this.ackInterval = setInterval(this.connectionHandler, 250);
    };

    Peer.prototype.connectionHandler = function() {
      this.send({
        request: "ack",
        status: 200
      });
      this.ack.requests++;
      if (this.ack.requests > 10) {
        clearInterval(this.ackInterval);
        return this.emit("disconnect", this);
      }
    };

    Peer.prototype.receive = function(data) {
      if (data.request === "ack") {
        if (!this.ack.acked) {
          this.ack.acked = true;
          this.emit("connect", this);
        }
        return this.ack.requests = 0;
      }
    };

    Peer.prototype.send = function(data, done) {
      data = new Buffer(JSON.stringify(data));
      return this.socket.send(data, 0, data.length, this.host["private"].port, this.host["private"].address, function(err, bytes) {
        if (err != null) {
          return socket.close();
        } else {
          if (typeof callback !== "undefined" && callback !== null) {
            return callback();
          }
        }
      });
    };

    return Peer;

  })(EventEmitter);

  UDPHoleClient = (function(_super) {
    __extends(UDPHoleClient, _super);

    function UDPHoleClient(options) {
      this.start = __bind(this.start, this);
      this.send = __bind(this.send, this);
      this.sendToHost = __bind(this.sendToHost, this);
      this.sendToServer = __bind(this.sendToServer, this);
      this.getPeer = __bind(this.getPeer, this);
      this.initProtocol = __bind(this.initProtocol, this);
      options.port = options.port || 1338;
      options.host = options.host || "127.0.0.1";
      this.privateAddress = null;
      this.server = {
        port: options.port,
        address: options.host
      };
      if (options.service == null) {
        throw new Error("Service now set");
      }
      this.service = options.service;
      this.socket = UDP.createSocket("udp4");
      this.peers = [];
    }

    UDPHoleClient.prototype.initProtocol = function(done) {
      this.socket.on("message", (function(_this) {
        return function(encodedData, publicInfo) {
          var connection, data, e, peer, _i, _len, _ref, _ref1;
          try {
            data = JSON.parse(encodedData);
          } catch (_error) {
            e = _error;
            return console.log("Cannot parse given data " + e + ": " + data);
          }
          if ((_ref = data.request) !== "connect" && _ref !== "register" && _ref !== "ack" && _ref !== "bye") {
            return _this.emit("data", _this.getPeer(publicInfo), data);
          }
          if (data.status !== 200) {
            return _this.emit("fail", data.request, data.status, data.message);
          }
          if (data.request === "connect") {
            _ref1 = data.hosts;
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              connection = _ref1[_i];
              peer = new Peer(connection, _this.socket);
              _this.peers.push(peer);
              peer.initialize();
              peer.on("disconnect", function(peer) {
                _this.peers.splice(_this.peers.indexOf(peer), 1);
                return _this.emit("disconnect", peer);
              });
              peer.on("connect", function(peer) {
                return _this.emit("connect", peer);
              });
            }
          }
          if (data.request === "register" && data.status === 200) {
            console.log("Registration of service \'" + _this.service.name + "\' successful");
          }
          if (data.request === "ack") {
            return _this.getPeer(publicInfo).receive(data);
          }
        };
      })(this));
      this.socket.on("listening", (function(_this) {
        return function() {
          var request;
          request = {
            service: _this.service,
            "private": {
              port: _this.socket.address().port,
              address: _this.privateAddress
            }
          };
          if (_this.service.host === true) {
            return _this.sendToServer("register", 200, request);
          } else {
            return _this.sendToServer("connect", 200, request);
          }
        };
      })(this));
      return Network.get_private_ip((function(_this) {
        return function(err, ip) {
          _this.privateAddress = ip;
          return done(err);
        };
      })(this));
    };

    UDPHoleClient.prototype.getPeer = function(host) {
      var peer, _i, _len, _ref;
      _ref = this.peers;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        peer = _ref[_i];
        if (peer.host["private"].port === host.port && peer.host["private"].address === host.address) {
          return peer;
        }
      }
      return null;
    };

    UDPHoleClient.prototype.sendToServer = function(request, status, data, done) {
      data.request = data.request || request;
      data.status = data.status || status;
      return this.sendToHost(this.server, data, done);
    };

    UDPHoleClient.prototype.sendToHost = function(host, data, done) {
      data = new Buffer(JSON.stringify(data));
      return this.socket.send(data, 0, data.length, host.port, host.address, function(err, bytes) {
        if (err != null) {
          return socket.close();
        } else {
          if (typeof callback !== "undefined" && callback !== null) {
            return callback();
          }
        }
      });
    };

    UDPHoleClient.prototype.send = function(data, done) {
      var peer, _i, _len, _ref, _results;
      _ref = this.peers;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        peer = _ref[_i];
        _results.push(peer.send(data, done));
      }
      return _results;
    };

    UDPHoleClient.prototype.start = function() {
      this.socket.removeAllListeners();
      return this.initProtocol((function(_this) {
        return function(err) {
          return _this.socket.bind();
        };
      })(this));
    };

    return UDPHoleClient;

  })(EventEmitter);

  module.exports.create = function(options) {
    return new UDPHoleClient(options);
  };

}).call(this);
